package org.amm.euler.p100;

/**
 * The sequence of triangle numbers is generated by adding the natural numbers.
 * So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
 * ten terms would be:
 * 
 * 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
 * 
 * Let us list the factors of the first seven triangle numbers:
 * 
 * 1: 1 
 * 3: 1,3 
 * 6: 1,2,3,6 
 * 10: 1,2,5,10 
 * 15: 1,3,5,15 
 * 21: 1,3,7,21 
 * 28: 1,2,4,7,14,28
 * 
 * We can see that 28 is the first triangle number to have over five divisors.
 * 
 * What is the value of the first triangle number to have over five hundred
 * divisors?
 * 
 */
public class Problem_12 {
	long run() {
		return 0;
		// int n = 3; //start with a prime
		// int Dn = 2; //number of divisors for any prime
		// int cnt = 0; //to insure the while loop is entered
		// int n1, Dn1, i, exponent;
		// int primearray[1..P];
		// while (cnt <= 500) {
		// n = n+1;
		// n1 = n;
		// if (n1 % 2 == 0) n1 = n1 / 2;
		// Dn1 = 1;
		// for (i = 0; i < P; i++){
		// //If your array indexing starts at 0, change to i=0 and i<P
		// if (primearray[i] * primearray[i] > n1)
		// Dn1 = 2 * Dn1; break;
		// //When the prime divisor would be greater than the residual n1,
		// //that residual n1 is the last prime factor with an exponent=1
		// //No necessity to identify it.
		// exponent = 1;
		// while (n1 % primearray[i] == 0) {
		// exponent++;
		// n1 = n1 / primearray[i];
		// }
		// if (exponent > 1) Dn1 *= exponent;
		// if (n1 == 1) break;
		// }
		// cnt = Dn * Dn1;
		// Dn = Dn1;
		// }
		// return n * (n - 1) / 2;

	}

	long run_0() {
		int t = 1; // triangle number
		int a = 1;
		int cnt = 0;
		while (cnt <= 500) {
			cnt = 0;
			a = a + 1;
			t = t + a;
			int ttx = (int) Math.sqrt(t);
			for (int i = 1; i <= ttx; i++) {
				if (t % i == 0)
					cnt += 2;
			}
			if (t == ttx * ttx)
				cnt--; // correction for a perfect square
		}
		return t;
	}
}
